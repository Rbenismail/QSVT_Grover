# -*- coding: utf-8 -*-
"""QSVT_GROVER.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/141cpPeF_U-hb3bJViyVQD8P2Rp0B8Tei
"""

import cvxpy as cp
import numpy as np
from math import *
import matplotlib.pyplot as plt

def create_shift_matrix(D):
    if D < 2:
        raise ValueError("Dimension must be at least 2.")

    # Create a matrix filled with zeros
    M = np.zeros((D, D-1), dtype=int)

    # Set the diagonal elements to 1
    for i in range(1, D):
        M[i, i-1] = 1

    return M

def QSVT_Grover(d,D,a):
      P = cp.Variable((D,D) , symmetric=True)
      Q = cp.Variable((D,D), symmetric=True)
      S = cp.Variable((D-1,D-1), symmetric=True)
      R = cp.Variable((D-1,D-1), symmetric=True)
      Q_1 = cp.Variable((D,D), symmetric=True)
      S_1 = cp.Variable((D-1,D-1), symmetric=True)
      R_1 = cp.Variable((D-1,D-1), symmetric=True)



      M = create_shift_matrix(D)

      Id = np.eye(D-1, D)

      I = np.zeros((D,D))
      I[0,0]=1


      constraints = [Q >> 0,R >> 0,S >> 0, Q_1 >> 0,R_1 >> 0,S_1 >> 0  ]
      for k in range(d+1):
              if k%2 == 0:
                  c = cp.sum([P[i, j] for i in range(D) for j in range(D) if (i + j) == k])
                  constraints+=[c==0]
      for l in range(d+1,2*D-1):
              c = cp.sum([P[i, j] for i in range(D) for j in range(D) if (i + j) == l])
              constraints+=[c==0]

      constraints+= [P+I == Q + 0.5 *(M @ R @ Id + Id.T @ R @ M.T) + Id.T @ R @ Id - 0.5 * (M @ S @ Id + Id.T @ S @ M.T) + Id.T @ S @ Id ]
      objective = cp.sum([P[i, j]*(a**k) for k in range(d+1) for i in range(D) for j in range(D) if (i + j) == k])

      prob = cp.Problem(cp.Maximize(objective), constraints)

      prob.solve()
      return objective.value, P.value

def super_Grover(d,D,a,b):
      delta = cp.Variable()
      P = cp.Variable((D,D) , symmetric=True)
      Q = cp.Variable((D,D), symmetric=True)
      S = cp.Variable((D-1,D-1), symmetric=True)
      R = cp.Variable((D-1,D-1), symmetric=True)
      Q_1 = cp.Variable((D,D), symmetric=True)
      S_1 = cp.Variable((D-1,D-1), symmetric=True)
      R_1 = cp.Variable((D-1,D-1), symmetric=True)



      M = create_shift_matrix(D)

      Id = np.eye(D-1, D)

      I = np.zeros((D,D))
      I[0,0]=1


      constraints = [Q >> 0,R >> 0,S >> 0, Q_1 >> 0,R_1 >> 0,S_1 >> 0  ]
      for k in range(d+1):
              if k%2 == 0:
                  c = cp.sum([P[i, j] for i in range(D) for j in range(D) if (i + j) == k])
                  constraints+=[c==0]
      for l in range(d+1,2*D-1):
              c = cp.sum([P[i, j] for i in range(D) for j in range(D) if (i + j) == l])
              constraints+=[c==0]

      constraints+= [P+I == Q + 0.5 *(M @ R @ Id + Id.T @ R @ M.T) + Id.T @ R @ Id - 0.5 * (M @ S @ Id + Id.T @ S @ M.T) + Id.T @ S @ Id ]
      constraints+= [P-I*(1-delta)  == Q_1 + 0.5 *(M @ R_1 @ Id + Id.T @ R_1 @ M.T) - a * Id.T @ R_1 @ Id - 0.5 * (M @ S_1 @ Id + Id.T @ S_1 @ M.T) +  b * Id.T @ S_1 @ Id ]

      prob = cp.Problem(cp.Minimize(delta), constraints)

      prob.solve()
      return delta.value, P.value